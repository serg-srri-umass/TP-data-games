<?xml version="1.0" encoding="utf-8"?>

<!-- ShipOdyssey.mxml -->
<!-- Copyright (c) 2011-2013 by University of Massachusetts and contributors -->
<!-- Project information: http://srri.umass.edu/datagames/ -->
<!-- Released under the MIT License http://www.opensource.org/licenses/mit-license.php -->
<!-- Keep Calm and Chive On -->
<!-- Terminology:
		Ship Odyssey - The name of this game/program.
		Goal -  The goal of this game is to hunt for treasure, by sending down diving rats and dropping hooks.
		Mission - Each game is called a "mission".
		Mission Level - There are multiple levels of difficulty, called 'Mission Levels" (internally, numbered 1-5 for 5 levels).
		Mission Title - Each level has a distinct title ("Hundreds o' rats", etc.)
		Site - Each mission has multiple 'Sites' to search for the treasure.
        Treasures - There are 0-2 treasures per site (1 treasure per site for most levels), and treasures have different names.
		Hook / Hook Drop - Drop a hook to find treasure at the current site.
		Rat / Send Rats - Send down rats to locate the treasure (they come up at the treasure location plus some random error (with a fixed standard deviation for that level).
		Game Data -  Data is sent to Data Games (DG), 
		Game Cases - each game has a Game Case (date about the current game),
		Event Cases - each event case has data about the dropped rat.
  -->

<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
			   xmlns:s="library://ns.adobe.com/flex/spark"
			   xmlns:mx="library://ns.adobe.com/flex/mx"
			   width="518" height="410" 
			   creationComplete="testFlashPlayer()" 
			   currentState="TreasureHunt"
			   activate="ScriptInterface.signalActivation()" 
			   deactivate="ScriptInterface.signalDeactivation()"
			   pageTitle="Ship Odyssey"
			   backgroundColor="#CCCCCC"
			   backgroundColor.TreasureHunt="#294867">
	<fx:Style source="ShipOdyssey.css"/>
	
	<fx:Script>
		<![CDATA[
			import com.adobe.serialization.json.JSON;
			
			import common.*;
			
			import flash.display.*;
			import flash.external.ExternalInterface;
			
			import odyssey.events.*;
			import odyssey.missions.*;
			
			private static const kMinimumRequiredVersion:Number = 11.6;	// the oldest version of flash player you can play this game on.
			private static const kDebugMode:Boolean = true; 			// set this to false, and the debug version will behave exactly like the release version.
			private static const kVersion:String = "v.2013.11.26";
			private static const kAboutTextHTML:String = 
				"<b>Ship Odyssey</b> is a <font color='#2C4877'><u><a href='http://www.srri.umass.edu/datagames' target='shipInfo'>Data Game</a></u></font>"+
				" created by the <font color='#2C4877'><u><a href='http://www.srri.umass.edu/serg' target='shipInfo'>Statistics Education Research Group</a></u></font>"+". "+
				"Contributers to the concept, design and development include the "+
				"Research and Activities team: Clifford Konold, Kosoom (Jang) Kreetong; "+
				"Developers: Craig D. Miller, Laurel Shortell; "+
				"Student Programmers: Tristan Warneke, Ryan McCann, Russ Phelan, Mike Salyh; "+ 
				"Artists: Josh Konold, Tristan Warneke, Mike Salyh. " +
				"Funded by the National Science Foundation, award "+
				"<font color='#2C4877'><u><a href='http://www.nsf.gov/awardsearch/showAward?AWD_ID=0918653&amp;HistoricalAwards=false' target='shipInfo'>DRL-0918653</a></u></font> (2009-2014). "+
				"Ship Odyssey is open source on <font color='#2C4877'><u><a href='https://github.com/serg-srri-umass/TP-data-games/wiki' target='shipInfo'>Github</a></u></font>. "+
				"Copyright (c) 2011<span class='x'>-2013 by University of Massachusetts Amherst.";
						
			// ********** TREASURE HUNT CONSTANTS AND VARIABLES ********** :variables:
			
			//-- Public Constants
			public static const kEventsCollectionName:String = "Events";
			public static const kGamesCollectionName:String = "Games";
			public static const kMinLocation:Number = 0;	// Leftmost treasure location.
			public static const kMaxLocation:Number = 100;	// Rightmost treasure location.
			public static const kMaxRatsToSend:int = 500; // the most rats that can be sent.
			public static const numTreasuresPerSiteSeed:Array = new Array(2, 0, 1, 2, 0, 1);	// this array is used on 'Treasure or Not', as the starting, unshuffled value.
			public static const posTreasuresPerSiteSeed:Array = new Array(0, 2, 1, 1, 2, 0, 1, 2, 0); // array used in 'Sea Walls' as the starting, unshuffled values.
																									// 0 = left wall, 1 = middle, 2 = right wall
			
			//-- Private variables
			private var mCurrentMission:MissionData;			// The current game mission.  
			
			private var mRatsToSend:uint	= 10;			// Rats to send at one time: should match current stepper value.
			private var mRandomNormal:ParkMiller;			// Class that creates a normal distribution.
			private var mCenterPosition:Number;				// Center position of grappling hook.
			private var mMinHookRange:Number;				// Left edge of hook's grasp.
			private var mMaxHookRange:Number;				// Right edge of hook's grasp.
			private var mNumTreasures:uint = 1;				// Number of treasures to find at the current location
			private var mCurrentTreasureNum:uint = 0;		// Starting treasure in zero-based array.
			private var mTreasuresFoundThisSite:uint= 0;	// Treasures found so far in current site (see BootyBarMVC.as for
			private var mSitesVisitedThisGame:uint = 0;		// Number of sites visited in current game.
			private var mSiteSerialNum:uint	= 0;			// Serial number of current site, beginning with 1 (does not reset for new game).
			private var mGameSerialNum:uint	= 0;			// Serial number of current game, beginning with 1
			private var mRatsSentThisSite:uint	= 0;		// Number of rats sent at the current site. Used to lock down the drop hook button.
			private var mFoundTreasure:Boolean = false; 	// Has the current hook drop found this treasure?
			//private	var	parentCaseID:int = -2;				// parent (game-level) case ID for DG; -2 means DG data not yet initialized, -1 means that no game case is open, 0+ is valid ID
			private var hooksDroppedArray:Array; 			// Array of hooks dropped at a site, where they were dropped, and what they pulled up. Used for replay window.
			private var numTreasuresPerSite:Array = new Array(); // this will hold how many treasures are at each site in Treasure or Not, for the first 6 sites.
			private var posTreasuresPerSite:Array = new Array(); // this will hold the location of treasures at each site in Sea Walls, for the first 8 sites.
			private var haveTreasure:Boolean = false; // whether you pulled up a treasure or not on your last hook drop.
			private var mTreasuresThisSite:Vector.<Treasure>;
			private var mDGInterface:DGInterface = null;	// interface to Data Games container application (if present)	
			
			//variables for holding loaded MovieClips
			private var popUpAPI:ShipMissionAPI = new ShipMissionAPI( newGame, getCurrentMission, setGameTitle, closeGame);	
			private var popUpScreen:PopUpScroll = new PopUpScroll(popUpAPI as ShipMissionAPI);
			private var topBarMVC:TopBarMVC = new TopBarMVC( showVideo, getDescription, showHideAbout);
			private var shipControlsMVC:ShipControlsMVC = new ShipControlsMVC();
			private var bootyMeter:BootyBarMVC = new BootyBarMVC();
			private var aboutScreen:AboutScreenMVC = new AboutScreenMVC( kAboutTextHTML);
			
			// the button on the top-bar that prompts you to watch the instructional video.
			private var mVideoButton:MovieClip = new videoMVC();
			
			//The Youtube video player for the intro video
			private var videoPlayer:Object;
			
			
			// ********** END OF TREASURE HUNT CONSTANTS AND VARIABLES **********
			
			// ********** TREASURE HUNT SOUNDS ********
			// Embed the cash earned sound in the Treasure Hunt game.
			// New Cash register sound by Benboncan (only modification is converted to MP3)
			// Downloaded from http://www.freesound.org/people/Benboncan/sounds/91924/ on Feb 7, 2012
			// Licensed under the attribution license (http://creativecommons.org/licenses/by/3.0/)
			[Embed(source="../embedded_assets/91924-benboncan-till-with-bell.mp3")]
			private var CashMP3:Class;
			private var mCashSound:Sound = new CashMP3() as Sound;
			
			//front fresound.org, liscenced under Creative Commons. Author: HerbertBoland
			[Embed(source="../embedded_assets/popSound.mp3")]
			private var popSoundMP3:Class;
			private var mPopSound:Sound = new popSoundMP3() as Sound;
			
			// Embed the rat squeal sound in the Treasure Hunt game.
			// The link from which the sound came no longer exists as of 10/28/2011. The larger
			// web site from which the sound came redirects to another site.
			// A similar rat sound on on the new site requires login to hear. The official web
			// site of those sounds creator lists rats sounds for a price.
			// Modified by shortening clip in Audacity on Mac.
			//			[Embed("../src/assets/Rat Sound.mp3")]
			//			private var RatMP3:Class;
			//			private var mRatSound:SoundAsset = new RatMP3() as SoundAsset;
			
			// ********** END TREASURE HUNT SOUNDS **********
			
			// test flash player makes sure the player is meeting the minimum requirements.
			private function testFlashPlayer():void {
				if( VersionChecker.isValid(kMinimumRequiredVersion)) {
					initPopUpScreen(); // the pop up screen has to be init'd before any other visual element, so we can show the word 'Loading'
					recheckTimer.addEventListener(TimerEvent.TIMER, checkSWFLoaders); // this timer checks every second whether or not loading is complete.
					checkSWFLoaders();
				} else {
					BrickWall.visible = true;
				}
			}
			
			// startUp() is called when the creation of this class is complete & 1nce each second, until all assets have loaded.
			// it sets up necessary parameters for game initiation.			
			private	function startUp():void	
			{
				BrickWall.visible = false;
				
				if(allAssetsLoaded){
					trace("FULL STARTUP!");
					recheckTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, checkSWFLoaders);
					recheckTimer.stop();
					
					mRandomNormal	= new ParkMiller();		// Create class that generates a normal distribution.
					

					// INITIALIZE ALL THE VISUAL ELEMENTS:
					initListeners();	// adds event listeners that exist for the entirety of the game.
					initVisualElements(); // any visual elements of .swc format are init'd here
					DivingRatDirector.init( ratContainer);	// pass the DivingRatDirector the container it's going to draw into.
					popUpScreen.displayMissionMap(); // show level selection on start up and start the game (true = start game after level selection)

					// INITIALIZE DG:
					// Note: Visual Elements are Init'd before the DG interface is created (so the game is ready to load a save file)
					mDGInterface = new DGInterface( VersionChecker.isDebug && kDebugMode );
					this.sendCollectionData();				// initialize the DG/TinkerPlots data interface (and set up Graph and Table parameters)
					// Note: restore state may be called here, if opening a saved DG document. 
					mDGInterface.createGraphIfNone();		// create a Graph view in DG, if not present already
					
					// EMBED YOUTUBE VIDEO:
					embedYoutubeVideo();
					
					
					// PROXY:
					
					//saveStateforDG(null);

					/*var progress:Object = {
						// VARS NEEDED TO RESTORE AN ODYSSEY:
						ratings: [3, 3, 4, 2, 0, 5],			// the scores on all missions so far
						deleteDataEachSite: false,				// whether or not the 'clear my graph' box was checked
						wasInGame: true, 						// if this is false, nothing below this line matters:
						
						// VARS NEEDED TO RESTORE A GAME:
						mission: 2,								// what mission ID we were playing (ie, 1: Hundreds o' Rats, 2: Rat Shortage, etc.)
						gameSerialNum: 2,						// how many games have been played so far
						siteSerialNum: 4,						// how many sites have been played so far
						sitesVisitedThisGame: 1,				// how many sites have been visited this game
						remainingRats: 52,						// rats remaining in booty meter
						remainingMisses: 1,						// hook drops remaining in booty meter
						treasuresFoundThisGame: 2,				// treasures found in booty meter
						wasInSite: true, 						// if this is false, nothing below this line matters:
						
						// VARS NEEDED TO RESTORE A SITE:
						treasuresFoundThisSite: 0,				// used in variable treasure levels
						treasuresRemaining: [98],				// array of treasure locations
						hooksDroppedArray: [[22, false, CraneEvent.GOT_NOTHING ]]	// array of hooks dropped so far, this game	
					}
					var progressWrapper:Object = {
						state: progress
					}*/
					//restoreStateforDG(progressWrapper); 	 

					// END PROXY 
					
				} else {
					recheckTimer.reset();
					recheckTimer.start();
					return; 
				}
			}
			
			private function embedYoutubeVideo():void{
				//Embedded Youtube video
				var videoID:String = "dDJ0oicZi1k";
				// to add a new video:
				// upload it to youtube using serg.srri.umass@gmail.com account
				// copy the 11 digit ID string which is in the URL and embed code
				
				Security.allowDomain("http://youtube.com"); //Allow flash to load assets from youtube
				Security.allowDomain("http://s.ytimg.com");
				
				var loader:Loader = new Loader();
				loader.contentLoaderInfo.addEventListener(Event.INIT, onLoaderInit);
				loader.load(new URLRequest("http://www.youtube.com/apiplayer?version=3"));
				//loader.load(new URLRequest("http://www.youtube.com/v/"+videoID+"?version=3&modestbranding=1&showinfo=1")); //player with controls
				function onLoaderInit(event:Event):void {
					videoHolder.addChild(loader);
					loader.content.addEventListener("onReady", onPlayerReady);
					function onPlayerReady(event:Event):void {
						videoPlayer = loader.content;
						videoPlayer.setSize(518, 308);
						videoPlayer.loadVideoById(videoID);
						videoPlayer.pauseVideo();
						videoPlayer.addEventListener("onStateChange", onVideoStateChange);
					}
				}
			}
			
			// set the rat stepper values and mRatsToSend.
			private function setRatsToSend( iCurrentRatsToSend:uint):void {
				// sync stepper
				shipControlsMVC.ratStepper.value = iCurrentRatsToSend;
			}
			
			// ********** TREASURE HUNT FUNCTIONS **********\			
			
			private function updateGameTitle():void{
				setGameTitle( mCurrentMission.title + "  (Game " + mGameSerialNum + ", Site " + mSiteSerialNum +")");
			}
			
			// start a new game.
			private function newGame( mission:MissionData, stripBtnListeners:Boolean):void{
				if(stripBtnListeners)
					popUpScreen.stripMissionButtonListeners();	// if this is being called from the pop-up screen, strip the button listeners off of that screen. 
				
				mCurrentMission = mission;
				sailingMovie.hardReset();
				
				// first update/close/delete old game case in DG, before we update mGameSerialNum, etc. for new game
				if( mDGInterface.isGameCaseOpen()) {
					sendGameDataClose();
				}
				
				//updateGameTitle(); // update the mission name and site number.				
				mGameSerialNum += 1;
				mSitesVisitedThisGame = 0;
				
				Water.fill = mission.waterGradient;
				Sky.backgroundFill = mission.skyGradient;
				cHerder.cleanClouds();
				cHerder.init( mission.cloudPattern);
				cHerder.startClouds();
				
				bootyMeter.nextSiteBtn.visible = mission.variableTreasures;
				if(mission.variableTreasures)
					numTreasuresPerSite = shuffleTreasuresPerSite();
				
				if(mission.seaWall)
					posTreasuresPerSite = shufflePositionPerSite();
				
				bootyMeter.initialize( mission.startingRats, mission.missesAllowed);
			
				mDGInterface.sendLog( "newGame: GameNumber="+mGameSerialNum+" Mission='"+mCurrentMission.title+"'" );
				newSite();
				
				setRatsToSend( mission.ratsInStepper);	// moving this down fixed a bug where the stepper did not properly take the starting # of rats in the stepper. (a very series issue for Mission 1)
				shipControlsMVC.useLargeRatButton = mission.fixedRats; 	// if this mission has a fixed # of rats, use the big button instead of the stepper.
				setHookSizes(mission.hookSize);
				
				crane.resetTreasure();
				
				// start a new Game case in DG
				sendGameDataOpen();
			}
						
			// randomLocation() creates a new location on the ocean floor based on a uniform
			// distribution.
			protected function randomLocation():Number
			{
				return ((kMaxLocation - kMinLocation) * mRandomNormal.uniform()) + kMinLocation;
			}
			
			// treasuresFoundString() returns a formatted string saying how many treasures were found out
			// of the total number of treasures available.
			protected function treasuresFoundString():String
			{
				if( mTreasuresThisSite.length == 1)
					return mTreasuresThisSite[0].toString();
				else if( mTreasuresThisSite.length == 2)
					return mTreasuresThisSite[0].toString() + "\n" + mTreasuresThisSite[1].toString();
				
				return "There were no treasures here.";
			}
			
			// this method returns an array of treasures-per-site, used in Mission "Treasures or Not".
			private function shuffleTreasuresPerSite():Array{
				// the # of treasures at a variable treasure site is pseudo-random.
				var newArray:Array = new Array();
				for(var i:int = 0; i < numTreasuresPerSiteSeed.length; i++)
					newArray.push(numTreasuresPerSiteSeed[i]);
				MathUtilities.shuffleArray(newArray, 1, 2);
				MathUtilities.shuffleArray(newArray, 3, 5);
				return newArray;
			}
			
			private function shufflePositionPerSite():Array{
				// the location of treasures in sea walls is pseudo-random.
				var newArray:Array = new Array();
				for( var i:int = 0; i < posTreasuresPerSiteSeed.length; i++)
					newArray.push( posTreasuresPerSiteSeed[i]);
				MathUtilities.shuffleArray(newArray, 0, 1);
				MathUtilities.shuffleArray( newArray, 3);
				return newArray;
			}
			
			// sends all hook movie clips to the passed frame. (1 = normal, 2 = small hook).
			private function setHookSizes(arg:int):void{
				crane.setHookSize( arg);
				sailingMovie.setHookSize( arg);
				ReplayHook.setHookSize( arg);
			}
			
			// ************MAIN GAME FUNCTIONS************
			// show how much the currently dropped rats are going to cost on the cost meter.
			protected function onMouseOverRatsButton(event:MouseEvent):void
			{
			}
			protected function onMouseOutRatsButton(event:MouseEvent):void
			{
			}

			// this function sets the max # of rats your stepper goes up to, based on how much $ you have.
			private function updateRatLimit():void{
				var maxRats:int = (mCurrentMission.ratCost == 0 ? kMaxRatsToSend : Math.max(bootyMeter.rats/mCurrentMission.ratCost, 0));
				if(maxRats > kMaxRatsToSend)
					maxRats = kMaxRatsToSend;
				shipControlsMVC.ratStepper.maxValue = maxRats;
			}
			
			// onClickSendRatsButton() is called when the Send Rats button is
			// pressed.
			protected function onClickSendRatsButton(event:MouseEvent = null):void{
				if( shipControlsMVC.ratStepper.validate()){ // check if the stepper is valid #, based on how much $ you have.
					if( mCurrentMission.ratCost > bootyMeter.rats){
						shipControlsMVC.ratStepper.gotoAndPlay("blink"); // make the stepper flash red if you can afford 0 rats.
					} else{
						if( mCurrentMission.ratCost > 0){ // pay if rats cost $
							bootyMeter.pay( mCurrentMission.ratCost * mRatsToSend);
							updateRatLimit();
						}
						mDGInterface.sendLog( "sendRats: "+mRatsToSend );
						
						//				mRatSound.play(); // Play rat sound.
						
						// For every rat sent, update Results text and send Rat data to TinkerPlots/DG
						
						var treasurePositions:Array = new Array(); // this array holds the position of each un-found treasure.
						for( var i:int = 0; i < mTreasuresThisSite.length; i++){
							if(!mTreasuresThisSite[i].found){
								treasurePositions.push(mTreasuresThisSite[i].location);
							}
						}
						
						var	numTreasuresHere:int = treasurePositions.length;
						var	noisyLocation:Number;
						var	evenOdd:int = 0;
						var	eventsAtATime:int = Math.max( 1, Math.round( mRatsToSend / 10 ));
						var	eventArray:Array = [];
						
						for( var ratNum:int = 0; ratNum < mRatsToSend; ++ratNum){
							mRatsSentThisSite +=1; // Increment rat counter.
							
							if( numTreasuresHere == 1){
								// Generate a noisy result based on the current treasure's location.
								noisyLocation = (mRandomNormal.standardNormal() * mCurrentMission.stdDeviation) + treasurePositions[0];

								if(mCurrentMission.seaWall){
									if(noisyLocation < kMinLocation){
										noisyLocation = kMinLocation + (Math.abs(noisyLocation)/5);
									} else if(noisyLocation > kMaxLocation){
										noisyLocation = kMaxLocation - ((noisyLocation - kMaxLocation)/5);
									}
								}
							} else if( numTreasuresHere == 0){
								//get random normal values from the entire range
								noisyLocation = randomLocation();
							} else if( numTreasuresHere == 2) {
								//do swap back and forth for two locations if they have 2 left
								noisyLocation = (mRandomNormal.standardNormal() * mCurrentMission.stdDeviation) + treasurePositions[evenOdd];
							}
							
							eventArray.push( getEventCaseValues( noisyLocation ));
							
							if( (ratNum + 1 == mRatsToSend) || (eventArray.length >= eventsAtATime )){
								DivingRatDirector.addRat( noisyLocation, eventArray);
								eventArray = []; // clear values already sent
							} else{
								DivingRatDirector.addRat( noisyLocation);					
							}
							evenOdd = (evenOdd + 1) % 2;
						}
						if( mRatsToSend > 0)
							DivingRatDirector.releaseRats();
					}
				}
			}
			
			// when a rat animation finishes, put the data on DG.
			private function finishRatDive(e:RatEvent):void {
				enableRatsButton(e);
				//popUpScreen.displayMessage("You're out of Rats!", "Use the data you've collected to make your final hook drops. This will be the last site of your game.");
				enableHookButton(e);

				// when the rat drop finishes, update the stepper if N is bigger than the # of rats you have left.
				updateRatLimit();
				shipControlsMVC.ratStepper.validate();
				
				pushRatDataToDG(e);
			}
			
			// put the rat data on DG, when the animation finishes
			private function pushRatDataToDG(e:RatEvent):void{
				for(var i:int = 0; i < DivingRatDirector.dataArray.length; i++){
					sendEventData( /*"Rat",*/  DivingRatDirector.dataArray[i]);	
				}
				DivingRatDirector.clearDataArray();
				sendGameDataUpdate();
			}
			
			// onChangeCenterPosition() is called when the value of the hook's
			// center position is changed.
			protected function onChangeCenterPosition(event:Event):void
			{
				// Update the hook's range based on the center position.
				//mCenterPositionStepper.value = mMathUtils.setPrecision(mCenterPositionStepper.value, kHookCenterPrecision);
				var prevCP:int 			= mCenterPosition;
				mCenterPosition			= shipControlsMVC.hookStepper.value; //mCenterPositionStepper.value;
				
				mMinHookRange			= mCenterPosition - mCurrentMission.hookRadius;	// Left edge of hook's grasp.
				mMaxHookRange			= mCenterPosition + mCurrentMission.hookRadius;	// Right edge of hook's grasp.
				
				shipControlsMVC.interval.text = mMinHookRange.toFixed(1) + " - " + mMaxHookRange.toFixed(1);
				
				if(crane){	// failsafe to ensure that the crane exists.
					if(event.type == KeyboardEvent.KEY_DOWN){
						crane.tweenTo(int(mCenterPosition), 1);
					} else {
						crane.toFrame( int(mCenterPosition));
					}
				}
			}
			
			// onChangeRatStepper() is called when the number of rats to be sent
			// is changed.
			protected function onChangeRatStepper(e:Event):void
			{
				// Update number of rats to be sent at one time.
				mRatsToSend = shipControlsMVC.ratStepper.value;
			}
			
			// show how much the hook drop is going to cost
			protected function onMouseOverDropHookButton(event:MouseEvent):void
			{
			}
			
			protected function onMouseOutDropHookButton(event:MouseEvent):void
			{
			}
			
			// onClickDropHookButton() is called when the Drop Hook button is
			// pressed and handles all actions assiociated with attempting to
			// retrieve treasure at the specified location.
			protected function onClickDropHookButton(event:MouseEvent = null):void
			{		
				disableAllButtons(); // this makes the next site button invisible
				bootyMeter.disableNextSiteButton(false);  // this makes the next site button visible, but disabled.
				
				crane.canDrag = false;
				
				shipControlsMVC.hookStepper.validate();
				//check to see if the crane needs to move before we can drop the hook
				//this happens if someone changes the value of the stepper and then clicks the Drop Hook button before the crane finishes moving
				if(mCenterPosition != shipControlsMVC.hookStepper.value || Math.abs(crane.getFrame()- mCenterPosition)>1){
					transitionTimer = new Timer(500, 0);
					transitionTimer.addEventListener(TimerEvent.TIMER,waitOnCraneMove);
					transitionTimer.start();
				} else {
					// Clear hint text next to pirate head.
					//mEventSerialNum 	+= 1; // Dropping a hook counts as an event.
					//mHooksDropped 	+= 1; // Increment counter of hooks dropped.
					
					// Check if we snagged any treasures
					mFoundTreasure = false;
					for( var i:int = 0; i < mTreasuresThisSite.length; i++){
						if( !mTreasuresThisSite[i].found && mTreasuresThisSite[i].location >= mMinHookRange && mTreasuresThisSite[i].location <= mMaxHookRange){
							mFoundTreasure = true;
							mTreasuresThisSite[i].found = true;
						}
					}
					dropHook();
				}
			}
			
			//wait and check timer routine for when the hook is moving before a drop
			private function waitOnCraneMove(e:TimerEvent):void{
				if(mCenterPosition == shipControlsMVC.hookStepper.value && Math.abs(crane.getFrame()- mCenterPosition)<1){
					transitionTimer.stop();
					transitionTimer.removeEventListener(TimerEvent.TIMER, waitOnCraneMove);
					onClickDropHookButton(new MouseEvent(MouseEvent.CLICK));
				}
			}
			
			//call the animation, disable all buttons during animation, and start a timer
			private function dropHook():void{
				var hookDropTime:Number = 1;
				var hookRaiseTime:Number = 2.75;
				
				crane.dropHook(mFoundTreasure, hookDropTime, hookRaiseTime);
				transitionTimer = new Timer( (hookDropTime + hookRaiseTime)*1000 , 1);
				transitionTimer.addEventListener(TimerEvent.TIMER_COMPLETE, hookDropTimerFinish);
				transitionTimer.start();
			}
			
			//return from dropHook()::transitionTimer.start()
			protected function hookDropTimerFinish(e:TimerEvent):void{
				//does the visual and sound items that occur after the hook drop finishes playing
				//or as the item on the hook comes into view
				transitionTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, hookDropTimerFinish);				
				
				hooksDroppedArray.push(new Array(mCenterPosition, mFoundTreasure, lastHookItem));
				mDGInterface.sendLog( "hookDropped: Center="+mCenterPosition+" TreasureFound="+mFoundTreasure ); // note: mCenterPosition may be changed below, so log now.
				
				if( mFoundTreasure)
				{
					// Add treasure value to accumulated wealth.
					bootyMeter.finishTreasureDrop(true);
					mCashSound.play(); // Play cash register sound.	
										
					if(mCurrentMission.variableTreasures) {	// if on "Treasure or Not"
						if(bootyMeter.isOutOfHooks){
							haveTreasure = true;
							zoomOutAndSail(); 
						} else {
							enableAllButtons();
						}
					} else { // on levels 1,3,4
						haveTreasure = true;
						popUpScreen.doReplay(hooksDroppedArray, mTreasuresThisSite, mCurrentMission.seaWall);
						zoomOutAndSail();
					}
					mTreasuresFoundThisSite++;
				}
				else // Treasure was not found at drop location.
				{
					//bootyMeter.pay(kCostPerHookDrop);	//pay, if only on misses.
					//updateRatLimit();
					haveTreasure = false;
					bootyMeter.finishTreasureDrop(false);
					//updateRatLimit();
					mPopSound.play(0, 0, (new SoundTransform(.5, 0)));
					if(!bootyMeter.isOutOfHooks){
						enableAllButtons();
					}else{
						popUpScreen.doReplay(hooksDroppedArray, mTreasuresThisSite, mCurrentMission.seaWall);
						zoomOutAndSail();
					}				
				}
				
				// send updated # of hooks dropped to DG game case
				sendGameDataUpdate();
			}
			
			//instead of incrementing mCurrentTreasureNum by 1 for each location, pick a random treasure so there is no limit.
			private function selectRandomTreasure():uint
			{
				//generate a random integer between [0,5]
				return Math.round(Math.random()*5) as uint;
			}		
			
			// This function is called when a site is complete. It sets everything back to how it started, and then shows the instant replay.
			// If you click 'end mission', this method isn't called because you don't want a replay.
			// this function was previously named exitGame
			private function finishSite(iEvent:Event = null):void{
				
				//clean up everything so it is back in initial state for start of next game
				crane.visible = false;
				sailingMovie.visible = true;
				sailingMovie.reset();
				//mCurrentGameComplete = true;// Game is now complete.	
				
				// add treasure to the deck of the ship
				if(haveTreasure){
					sailingMovie.addTreasure();
					crane.addTreasure();
				}
				
				if(!popUpScreen.visible){
					if(haveTreasure || bootyMeter.isOutOfHooks || bootyMeter.isOutOfRats){
						haveTreasure = false;
						//var valueInDollars:String = TextFormatter.toCash(mTreasuresThisSite[mCurrentTreasureNum][kValue]);
						if(bootyMeter.isOutOfHooks || bootyMeter.isOutOfRats){
							popUpScreen.displayInstantReplay(treasuresFoundString(), popUpScreen.displayGameOver, true);
						}else{
							popUpScreen.displayInstantReplay(treasuresFoundString(), newSite);
						}
					}else{
						popUpScreen.doReplay(hooksDroppedArray, mTreasuresThisSite, mCurrentMission.seaWall);
						popUpScreen.displayInstantReplay(treasuresFoundString(), newSite);
					}
				}
				mDGInterface.sendLog( "treasureMessage: '"+treasuresFoundString()+"'");

				shipControlsMVC.disableRatsButton();
				shipControlsMVC.disableHookButton();
				shipControlsMVC.hookStepper.enabled = false;
				shipControlsMVC.ratStepper.enabled = false;
				
				popUpScreen.treasuresFound = bootyMeter.treasuresFound;
				popUpScreen.rating = getRating();
			}
			
			// this method is called when the user clicks 'okay' on the "Game Over" popup. It closes the game in DG. 
			private function closeGame(e:Event = null):void{
				sendGameDataClose();
			}
			
			// this method is called on "Treasure or Not". When you get the treasure, take it off the hook, and put it on deck.
			private function putTreasureOnDeck():void{
				crane.addTreasure(); // adds treasure to the ship deck
				crane.hideTreasure(); // hides treasure from the ship hook
				sailingMovie.addTreasure(); 
			}
			
			private function getRating():int{
				return mCurrentMission.getRating(bootyMeter.treasuresFound);
			}
			
			// set up our game for a new site.
			private function newSite(iEvent:Event = null):void {
				if( popUpScreen.deleteData )  {
					mDGInterface.deletePreviousCaseData();
				}
				
				
				popUpScreen.visible = false;
				readyToZoomIn();
				disableAllButtons();
				
				
				mSiteSerialNum			+= 1;
				mSitesVisitedThisGame 	+= 1;
				mTreasuresFoundThisSite	= 0;	// No treasures found yet.
				mRatsSentThisSite				= 0;	// Reset number of rats sent.
				//mHooksDropped			= 0;	// Reset number of hooks dropped.
				
				var numTreasuresThisSite:int = createNumTreasuresThisSite();
				mTreasuresThisSite = new Vector.<Treasure>();
				for( var i:int = 0; i < numTreasuresThisSite; i++)
					mTreasuresThisSite.push( new Treasure( TreasureNamePicker.poolShift( mCurrentMission.number), generateTreasurePosition()));
						
				if(mTreasuresThisSite.length == 2){
					// this while loop ensures that the two treasures are sufficiently far apart.
					while(Math.abs( mTreasuresThisSite[0].location - mTreasuresThisSite[1].location) < 30)
						mTreasuresThisSite[0].location = randomLocation();
				}
				
				// Move hook to its starting position.
				mCenterPosition						= 100;	
				shipControlsMVC.hookStepper.value	= mCenterPosition;					// Set stepper to center position.
				mMinHookRange						= mCenterPosition - mCurrentMission.hookRadius;	// Left edge of hook's grasp.
				mMaxHookRange						= mCenterPosition + mCurrentMission.hookRadius; //mHookRadius;	// Right edge of hook's grasp.
				shipControlsMVC.interval.text		= mMinHookRange.toFixed(1) + " â€“ " + mMaxHookRange.toFixed(1);
				hooksDroppedArray = new Array();

				mDGInterface.sendLog( "newSite: Site="+mSiteSerialNum+" SitesVisited="+mSitesVisitedThisGame );
				
				if( mSitesVisitedThisGame >= 2){
					sendGameDataUpdate(); // send updated SitesVisited to DG
				}
				
				updateRatLimit();
				updateGameTitle();
				
				if(VersionChecker.isDebug && kDebugMode)
				{
					trace(treasuresFoundString());
				}
			}
			
			// generate where the treasure's position is:
			private function generateTreasurePosition():Number{
				// if sea wall, pseduo-randomly place the treasures
				if( mCurrentMission.seaWall){
					var treasureSwitch:int;
					if( posTreasuresPerSite.length)
						treasureSwitch = posTreasuresPerSite.shift();
					 else 
						treasureSwitch = Math.random() * 3;
					
					switch(treasureSwitch){
						case 0: // left wall
							return Math.floor( Math.random() * 4) + 3;
						case 2: // right wall
							return Math.floor( Math.random() * 4) + 94;
						case 1: // walls still there, but treasure is positioned for no effect 
							return Math.floor( Math.random() * 49) + 25;
						default: 
							throw new Error("key for switch at generateTreasurePosition() is out of range");
							return randomLocation();
					}
					// otherwise, the treasure's position is truely random:
				} else {
					return randomLocation();
				}
			}
			
			// returns the # of treasures that will be at the current site. Called at the start of a new site.
			private function createNumTreasuresThisSite():int{
				if(mCurrentMission.variableTreasures){
					if(numTreasuresPerSite.length)
						return numTreasuresPerSite.shift();
					else 
						return Math.random()*3;	// when the pseduo-random array is depleted, use real random.
				}
				return 1;
			}
			
			
			// TO-DO: should we change this, or make it work? It's not being called at all right now.
			private function updateProfitAfterSail():void{
				//update the cumulative cost of using the ship and crew as well as the profit so far
				mCurrentTreasureNum = selectRandomTreasure();
			}
			
			// send the Game-level data to TinkerPlots or DG.
			// this creates and opens the game case, see also sendGameDataClose()
			private function sendGameDataOpen():void {
				var closeCase:Boolean = false;
				this.mDGInterface.openGameCase( kGamesCollectionName, getGameCaseValues( closeCase ));
			}
			
			// if connected to DG, updates and closes the game-level case data created by sendGameDataOpen()
			private function sendGameDataClose():void{
				var closeCase:Boolean = true,
					numTreasures:int = bootyMeter.treasuresFound,
					ratingNum:int = mCurrentMission.getRating( numTreasures );
				this.mDGInterface.sendLog( "gameOver: Rating="+ratingNum+" TreasuresFound="+numTreasures );
				this.mDGInterface.updateOrCloseGameCase( kGamesCollectionName, getGameCaseValues( closeCase ), closeCase );
			}
			
			// if connected to DG, updates the game-level case data created by sendGameDataOpen()
			private function sendGameDataUpdate():void {
				var closeCase:Boolean = false;
				this.mDGInterface.updateOrCloseGameCase( kGamesCollectionName, getGameCaseValues( closeCase ), closeCase );
			}
			
			// Send event case data to DG, if connected to DG.
			// 		Event data are "Rat Sent" events (one rat sending per case); we no longer send "Hook dropped" events
			// 		caseValueArrays is an array of cases, and each case is a array of attribute values for that case (corresponding to the attributes previously sent)
			private function sendEventData( caseValueArrays:Array ):void {
				this.mDGInterface.createEventCases( kEventsCollectionName, caseValueArrays );
			}
			
			// Send the Game-level and Event-level structure to DG, if connected to DG.  
			// 		The collections are the tables of cases and attributes.
			private	function sendCollectionData( ):void	{
				var initGameArgs:Object = 
					{
						name: "ShipOdyssey",
						dimensions: { width: this.width, height: this.height },
						gameEmbedID: 'ShipOdyssey', // must match the ID of ChainSaw.swf embedded in the DG page by ChainSaw.html
						gameEmbedFunc: 'doCommandFunc', // callback function name to be used by DG/javascript
						collections: [
							{
								name: kGamesCollectionName,
								attrs:[
									{name: "GameNumber", type: "numeric", description: "Sequential Game Number" },
									{name: "MissionName", type: "nominal", description: "Which mission? (objective and level of difficulty)" },
									{name: "Rating", type: "numeric", description: "Game play rating from 1 (worst) to 5 (best)" },
									{name: "TreasuresFound", type: "numeric", precision: 0, description: "Number of treasures found during game" }, 
									{name: "SitesVisited", type: "numeric", precision: 0, description: "Number of sites visited during game" },
									{name: "RatsSent", type: "numeric", precision: 0, description: "Number of rats sent during game" }	
								] ,
								childAttrName: "Events_Record"
							},
							{
								name: kEventsCollectionName,
								attrs:	[
									{ name: "Site", type: "nominal", description: "Site number"   } ,
									{ name: "RatNumber", type: "numeric", precision: 0, description: "Rats sent so far in game"   } , 
									{ name: "RatReading", type: "numeric", precision: 1, defaultMin: 0, defaultMax: 100, description: "Location estimate provided by rat"  }
								],
								labels: {
									singleCase: "rat sent",
									pluralCase: "rats sent",
									singleCaseWithArticle: "a rat reading",
									setOfCases: "events",
									setOfCasesWithArticle: "events"
								},
								defaults: { xAttr: "RatReading", yAttr: "Site" }
							}
						] // collections
					};
				ExternalInterface.addCallback( "doCommandFunc", doCommandFromDG ); // make {InferenceGames.swf}.doCommandFromDG() callable from javascript/DG
				this.mDGInterface.initGame( initGameArgs );
			}
			
			// handle a command from DG, such as 'restoreState' or 'saveState'.  
			// 		this.startUp( ) registers this callback function with DG,
			// 		so DG can ask for game state then restore that game state when a DG document is saved then later opened.
			// 		expecting string from DG like: '{ operation: 'restoreState', args: { state: restoredGameState }}'
			public function doCommandFromDG( commandString:String ):String {
				var resultObj:Object = { success: false },
					result:String,
					commandObj:Object = com.adobe.serialization.json.JSON.decode( commandString );
				
				if( commandObj.operation == 'saveState' ) {
					resultObj = this.saveStateforDG( commandObj.args );
				} else if (commandObj.operation == 'restoreState' ) {
					resultObj = this.restoreStateforDG( commandObj.args );
				}		
				if( resultObj )
					result = com.adobe.serialization.json.JSON.encode( resultObj );
				return result;
			}
			
			// handle a 'saveState' command from DG, to stave this game in a document  
			// 		We return information to be passed back to the this game with a restoreStateForDg() call.
			//		Warning: must be compatible with different versions of restoreStateforDG()
			//		Returns { success: true, state: {} }
			private function saveStateforDG( args:Object ):Object {
				
				var mWasInGame:Boolean = isInGame();
				var mWasInSite:Boolean = isInSite();
				var stateObj:Object;
				
				if( mWasInGame && mWasInSite){
					stateObj = {
						success: true,
						state: {
							// VARS NEEDED TO RESTORE AN ODYSSEY:
							ratings: Missions.getBestRatings(),					// the scores on all missions so far
							deleteDataEachSite: popUpScreen.deleteData,			// whether or not the 'clear my graph' box was checked
							wasInGame: true, 								// if this is false, nothing below this line matters:
							
							// VARS NEEDED TO RESTORE A GAME:
							mission: mCurrentMission.number,					// what mission ID we were playing (ie, 1: Hundreds o' Rats, 2: Rat Shortage, etc.)
							gameSerialNum: mGameSerialNum,						// how many games have been played so far
							siteSerialNum: mSiteSerialNum,						// how many sites have been played so far
							sitesVisitedThisGame: mSitesVisitedThisGame,		// how many sites have been visited this game
							remainingRats: bootyMeter.rats,						// rats remaining in booty meter
							remainingMisses: bootyMeter.missesRemaining,			// hook drops remaining in booty meter
							treasuresFoundThisGame: bootyMeter.treasuresFound,	// treasures found in booty meter
							wasInSite: true, 								// if this is false, nothing below this line matters:
							
							// VARS NEEDED TO RESTORE A SITE:
							treasuresFoundThisSite: mTreasuresFoundThisSite,	// used in variable treasure levels
							treasuresRemaining: getTreasureRemainingArray(),	// array of treasure locations
							hooksDroppedArray: hooksDroppedArray				// array of hooks dropped so far, this game	
						}
					};
				} else if ( mWasInGame) {
					stateObj = {
						success: true,
						state: {
							// VARS NEEDED TO RESTORE AN ODYSSEY:
							ratings: Missions.getBestRatings(),					// the scores on all missions so far
							deleteDataEachSite: popUpScreen.deleteData,			// whether or not the 'clear my graph' box was checked
							wasInGame: true, 								// if this is false, nothing below this line matters:
								
							// VARS NEEDED TO RESTORE A GAME:
							mission: mCurrentMission.number,					// what mission ID we were playing (ie, 1: Hundreds o' Rats, 2: Rat Shortage, etc.)
							gameSerialNum: mGameSerialNum,						// how many games have been played so far
							siteSerialNum: mSiteSerialNum,						// how many sites have been played so far
							sitesVisitedThisGame: mSitesVisitedThisGame,		// how many sites have been visited this game
							remainingRats: bootyMeter.rats,						// rats remaining in booty meter
							remainingMisses: bootyMeter.missesRemaining,		// hook drops remaining in booty meter
							treasuresFoundThisGame: bootyMeter.treasuresFound,	// treasures found in booty meter
							wasInSite: false								
						}
					};
				} else {
					stateObj = {
						success: true,
						state: {
							// VARS NEEDED TO RESTORE AN ODYSSEY:
							ratings: Missions.getBestRatings(),					// the scores on all missions so far
							deleteDataEachSite: popUpScreen.deleteData,			// whether or not the 'clear my graph' box was checked
							wasInGame: false 								// if this is false, nothing below this line matters:					
						}
					};
				}
				return stateObj;
			}
			
			// this method checks if the player is 'in game'.
			private function isInGame():Boolean{

				if( popUpScreen.visible && popUpScreen.currentLabel == "level") // if the map selector is showing
					return false;
				
				if( bootyMeter.isOutOfHooks) // if you're out of hooks, the game is over
					return false;
				
				if( bootyMeter.isOutOfRats && !isInSite()) // if you're out of rats and not at a site, the game is over
					return false;
				
				return true;
			}

			// this method checks if the player is in the middle of playing a site
			private function isInSite():Boolean{
				if( popUpScreen.visible && popUpScreen.currentLabel == "recap") // if the replay is showing
					return false;
				
				if( bootyMeter.isOutOfHooks) // if you're out of hooks, the game is over
					return false;
				
				if( haveTreasure)	// if you have a treasure on your hook, the site is over
					return false;
							
				return true;
			}
			
			// creates an array of the positions of all treasures that are live:
			private function getTreasureRemainingArray():Array{
				var returnArray:Array = new Array();
				for( var i:int = 0; i < mTreasuresThisSite.length; i++){
					if( !mTreasuresThisSite[i].found)
						returnArray.push( mTreasuresThisSite[i].location);
				}
				return returnArray;
			}
			
			// handle a 'restoreState' command from DG, to restore a game saved in a document.  
			// 		Handles parameters created by a previous save of saveStateForDG()
			//		Warning: must be backward compatible with data created by older versions of saveStateForDG()
			// 		Returns { success: true/false }
			private function restoreStateforDG( args:Object ):Object {
				var iState:Object = args.state,
					result:Object = { success: false };
				if( iState )  // restore our parameters as independently as possible
				{
					result.success = true;
					var validator:RestoreValidator = new RestoreValidator();	// this objects handles the restoration of save states.
					if( validator.validateOdysseyRestore( iState)){								// CHECK IF ANYTHING CAN BE RESTORED (TOP LEVEL)
						restoreOdyssey(iState);
						if( iState.wasInGame && validator.validateGameRestore( iState)){			// CHECK IF A GAME WAS UNDERWAY, AND CAN BE RESTORED
							restoreGame(iState);
							if( iState.wasInSite && validator.validateSiteRestore( iState)){		// CHECK IF A SITE WAS UNDERWAY, AND CAN BE RESTORED
								restoreSite(iState);
							} else{
								newSite(); // if a site isn't being restored, create a new site.
							}
						} else {
							popUpScreen.displayMissionMap( true); // if a game isn't being restored, return to the map.
						}
					} else { // could not restore anything:
						result.sucess = false;	// if nothing could be restored, this opperation was a failure.
					}
				}
				return result;
			}	
			
			// get the game case data to send to Tinkerplots/DG, 
			// returned as an array for use by sendGameDataOpen(),..Update(),...Close().
			private function getGameCaseValues( iIsGameOver:Boolean ):Array {
				return [
					mGameSerialNum,		 // Game number starting with 1 since launch of application.
					mCurrentMission.title,
					(iIsGameOver ? mCurrentMission.getRating( bootyMeter.treasuresFound ) : null ),
					bootyMeter.treasuresFound,
					mSitesVisitedThisGame,
					bootyMeter.getNumRatsDropped()
				];
			}
			
			// get the event data to send to Tinkerplots/DG, 
			// returned as an array for use by sendEventData()
			private function getEventCaseValues( iRatReading:Number ):Array {
				return [
					mSiteSerialNum, // Game number (1-n)
					mRatsSentThisSite, // Rat number (1-n)
					iRatReading // Location estimate provided by rat.
				];
			}
			
			//timer response functions for running the game (will inline them near where they go as it makes sense)
			//(decouples visual with state and play so a broken animation doesn't stop play)
			private function zoomOutAndSail(e:Event = null):void{
				disableAllButtons();
				var craneFrame:int = crane.getFrame();
				
				cHerder.setCloudSpeed(-.5);
				shipControlsMVC.hookStepper.value = 100;
				onChangeCenterPosition(new Event("Stepper"));
				DivingRatDirector.abortDive();	//when you click next site, if any rats are being animated, this takes care of them.

				transitionTimer = new Timer(1900, 1); //timer is in milliseconds
				transitionTimer.addEventListener(TimerEvent.TIMER_COMPLETE, finishSite);
				
				sailingMovie.visible = true;
				crane.visible = false;
				sailingMovie.doZoomOut(haveTreasure);
				sailingMovie.sendCraneToFrame(craneFrame);
				transitionTimer.start()
			} 
			
			// start of zoom-in with the sailing animation. 5 seconds later, it calls zoomInTimerFinish()
			private function readyToZoomIn():void{
				sailingMovie.reset();
				cHerder.setCloudSpeed(1.5);
				transitionTimer = new Timer(5000, 1);
				transitionTimer.addEventListener(TimerEvent.TIMER_COMPLETE, zoomInTimerFinish);
				sailingMovie.doZoomIn();
				transitionTimer.start();
			}
			
			// called when the sailing animation finishes zooming in. Enables the buttons and let's the user start playing.
			private function zoomInTimerFinish(e:TimerEvent = null):void{
				crane.establish();
				sailingMovie.visible = false;
				enableAllButtons();
			}
			
			//currently unused since there are no rat drop sounds or anims
			private function ratDropTimerFinish(e:TimerEvent):void{
				
			}
			
			//button control methods
			private function disableAllButtons(e:Event = null):void{
				shipControlsMVC.hookStepper.enabled = false;
				shipControlsMVC.disableHookButton();
				shipControlsMVC.ratStepper.enabled = false;
				shipControlsMVC.disableRatsButton();
				//topBarMVC.disableHelpButton();
				bootyMeter.disableEndMissionButton();
				bootyMeter.disableNextSiteButton();
				
				if(crane)	// failsafe to prevent the crane from being turned off before it loads.
					crane.canDrag = false;
			}	
			
			private function enableAllButtons():void{
				//topBarMVC.enableHelpButton();
				shipControlsMVC.hookStepper.enabled = true;
				shipControlsMVC.ratStepper.enabled = true;
				shipControlsMVC.enableRatsButton();
				bootyMeter.enableNextSiteButton();
				bootyMeter.enableEndMissionButton();

				enableHookButton(); // this function ensures that the hook button SHOULD be enabled before doing it.
				if(crane)//failsafe for crane loading
					crane.canDrag = true;
			}
			
			private function disableRatHookButton(e:RatEvent = null):void{
				shipControlsMVC.disableRatsButton();
				shipControlsMVC.ratStepper.enabled = false;
				shipControlsMVC.disableHookButton();
				shipControlsMVC.hookStepper.enabled = false;
				//if(crane)
					//crane.canDrag = false;
			}
			
			// turns on the rat button & stepper, assuming you have any rats.
			private function enableRatsButton(e:Event = null):void{
				if(!bootyMeter.isOutOfRats){
					shipControlsMVC.ratStepper.enabled = true;
					shipControlsMVC.enableRatsButton();
				}
			}
			
			private function enableHookButton(e:Event = null):void{
				if( (VersionChecker.isDebug && kDebugMode) || mRatsSentThisSite > 0){
					shipControlsMVC.enableHookButton();
					shipControlsMVC.hookStepper.enabled = true;
					if(crane)
						crane.canDrag = true;
				}
			}
			
			//********new visual items and visual only code **********
			private var crane:MovieClip;			
			private var sailingMovie:MovieClip;
			private var cHerder:MovieClip;
			
			private var allAssetsLoaded:Boolean = false; // set to true when all SWF loaders are done.
			protected var recheckTimer:Timer = new Timer(1000, 1)
			
			private var skyAreaMask:Shape;
			private var sailMask:Shape;
			private var craneMask:Shape;
			private var transitionTimer:Timer;
			private var dayTickOffClockTimer:Timer;
			
			//ties the crane to MXML loader and sets up the mask
			private function initCrane():void{
				crane = CraneLoader.content as MovieClip;
				
				crane.visible = false;
				craneMask = new Shape();
				craneMask.graphics.beginFill(0x000000);
				craneMask.graphics.drawRect(0,0,395,286);
				uic.addChild(craneMask);//have to add masks to display list or else RemovePopUp will hide them and the object they are masking
				crane.mask = craneMask;
				crane.addEventListener(CraneEvent.DRAGGING, updateCraneStepper);
				crane.addEventListener(CraneEvent.SCALE_CLICKED, updateCraneStepperSnapped);
				
				crane.addEventListener(CraneEvent.GOT_BOOT, handleGettingJunk);
				crane.addEventListener(CraneEvent.GOT_SEAWEED, handleGettingJunk);
				crane.addEventListener(CraneEvent.GOT_NOTHING, handleGettingJunk);

				//checkSWFLoaders();
			}
			
			private var lastHookItem:String;
			private function handleGettingJunk(e:Event):void{
				lastHookItem = e.type;
			}
			
			private function updateCraneStepper(e:Event):void{
				var value:int = crane.getFrame();
				if(value == 1 && crane.zeroed)
					value = 0;
				shipControlsMVC.hookStepper.value = crane.value;
				shipControlsMVC.hookStepper.validate();
				onChangeCenterPosition(e);
			}
			private function updateCraneStepperSnapped(e:Event):void{
				shipControlsMVC.hookStepper.value = crane.snappingPoint;
				onChangeCenterPosition(e);
			}
			
			//loads the swf, sets colors, and starts the clouds
			private function initClouds():void{	
				cHerder = CloudLoader.content as MovieClip;
				skyAreaMask = new Shape();
				skyAreaMask.graphics.beginFill(0x000000);
				skyAreaMask.graphics.drawRect(0,0,395,186);
				uic.addChild(skyAreaMask);//have to add masks to display list or else RemovePopUp will hide them and the object they are masking
				cHerder.mask = skyAreaMask;
				//checkSWFLoaders();
			}
			
			//ties boat swf loader to code
			private function initBoat():void{				
				//load boat
				sailingMovie = BoatLoader.content as MovieClip;
				//set zoom variables
				sailingMovie.zoomTime = 48;
				sailingMovie.finalX = -26;
				sailingMovie.finalY = -122;
				//set mask so zoom doesn't go outside box
				sailMask = new Shape();
				sailMask.graphics.beginFill(0x000000);
				sailMask.graphics.drawRect(0,0,395,286);
				uic.addChild(sailMask);//have to add masks to display list or else RemovePopUp will hide them and the object they are masking
				sailingMovie.mask = sailMask;
				//start sailing
				sailingMovie.ToyBoat.startSail(); 
				//checkSWFLoaders();
			}

			private function checkSWFLoaders( e:Event = null):void{
				if(crane && cHerder && sailingMovie) {
					allAssetsLoaded = true;
				}
				startUp();
			}
			
			private function setGameTitle(arg:String):void {
				topBarMVC.setTitle(arg);
			}
			
			private function getCurrentMission():int{ 
				return mCurrentMission.number; 
			}
			
			private function getDescription():String{
				if(!mCurrentMission){
					return "";
				}
				return mCurrentMission.instructions;
			}

			// This function is called when the game starts. These objects will have the following listeners for the entirety of the play session:
			private function initListeners():void{
				DivingRatDirector.dispatcher.addEventListener(RatEvent.RELEASED, disableRatHookButton);
				DivingRatDirector.dispatcher.addEventListener(RatEvent.RETURNED, finishRatDive);
			}
			
			// init the popupscreen before all other visual elements, so it can show 'LOADING', while waiting for the rest to come in.
			private function initPopUpScreen():void{
				popUpContainer.addChild(popUpScreen);
				popUpScreen.showLoading();
			}
			
			// Add visual SWC files to the screen
			private function initVisualElements():void{	
				bootyMeterContainer.addChild(bootyMeter);
				bootyMeter.nextSiteFunction = zoomOutAndSail;
				bootyMeter.endMissionFunction = endGame;
				
				popUpContainer.addChild(shipControlsMVC);
				shipControlsMVC.x = 7;
				shipControlsMVC.y = 35;
				shipControlsMVC.setRatButtonFunction(onClickSendRatsButton);
				shipControlsMVC.setHookButtonFunction(onClickDropHookButton);
				shipControlsMVC.ratStepper.setOnChangeFunction(onChangeRatStepper);
				shipControlsMVC.hookStepper.setOnChangeFunction(onChangeCenterPosition);
				
				if(popUpScreen.parent == popUpContainer){
					popUpContainer.swapChildren(popUpScreen, shipControlsMVC); // put the pop-ups on top of everything else if they've already been loaded
				} else {
					popUpContainer.addChild(popUpScreen); // otherwise, add them here
					popUpScreen.showLoading(); 
				}
				
				popUpContainer.addChild( aboutScreen);
				
				topBarContainer.addChild(topBarMVC);
				topBarMVC.setVersion(kVersion);
				topBarMVC.setStage(this.systemManager.stage);
				
				addEventListener(MouseEvent.CLICK, handleFocus);
			}	
			
			//MXML's with multiple SWF's handle focus in a strange way. This keeps the focus working the way it should.
			private function handleFocus(e:MouseEvent):void{
				var clickingTextField:Boolean = (e.target is TextField);
				if(!clickingTextField)
					this.setFocus();
			}

			// the user has clicked the End Game button, we must confirm that next.
			private function endGame(e:Event = null):void{
				popUpScreen.confirmAction(endGameConfirmed);
			}
			
			// the user has confirmed that they want to end the game, now we show them their score.
			// see also newGame().
			private function endGameConfirmed(e:Event = null):void{					
				sailingMovie.hardReset();	//the ship sailing movie will be zoomed out.
				sailingMovie.visible = true;
				crane.visible = false;
				shipControlsMVC.hookStepper.value = 100;
				onChangeCenterPosition(new Event("Stepper"));
				DivingRatDirector.abortDive();	//if any rats are being animated, this takes care of them.

				popUpScreen.treasuresFound = bootyMeter.treasuresFound;
				popUpScreen.rating = getRating();
				
				if( bootyMeter.treasuresFound > 0){
					popUpScreen.displayGameOver();
				} else {
					popUpScreen.displayMissionMap( true);
					closeGame();
				}
				
				if( popUpScreen.deleteData )  {
					mDGInterface.deletePreviousCaseData();
				}
				
				mDGInterface.sendLog( "endGameButtonPress:" );
			}

			//Video functions
			private function showVideo( e:MouseEvent = null):Boolean{
				if(StartupVideo.visible == true){
					if(videoPlayer != null){
						videoPlayer.pauseVideo();
					}
					StartupVideo.visible = false;
					return false;
				} else{
					StartupVideo.visible = true;
					videoPlayer.playVideo();
					return true;
				}
			}
			private function hideVideo():void{
				StartupVideo.visible = false;
				videoPlayer.pauseVideo();
			}
			private function playPauseVideo():void{
				var PLAYING_VIDEO:Number = 1;
				if(videoPlayer.getPlayerState() == PLAYING_VIDEO) {
					videoPlayer.pauseVideo();
				} else{
					videoPlayer.playVideo();
				}
			}
			private function replayVideo():void{
				videoPlayer.seekTo(0, true);
				videoPlayer.playVideo();
			}
			private function onVideoStateChange(e:Event):void
			{
				var PLAY:int=1, PAUSE:int=2;
				var state:int = Object(e).data;
				switch(state)
				{
					case PLAY:
						playPauseBtn.label = "Pause"; break;
					case PAUSE:
						playPauseBtn.label = "Play"; break;
				}
			}
			
			/* ABOUT FUNCTIONS */
			// toggles the visibility of the about screen
			private function showHideAbout():void{
				aboutScreen.visible = ! aboutScreen.visible;
			}
			
			/* SAVING LOADING FUNCTIONS */
			
			private function restoreOdyssey(progress:Object):void{				
				// restore the star ratings:
				Missions.getMission(1).bestRating = progress.ratings[0];
				Missions.getMission(2).bestRating = progress.ratings[1];
				Missions.getMission(3).bestRating = progress.ratings[2];
				Missions.getMission(4).bestRating = progress.ratings[3];
				Missions.getMission(5).bestRating = progress.ratings[4];
				Missions.getMission(6).bestRating = progress.ratings[5];
				
				// restore the 'clear my graph' checkbox setting:
				popUpScreen.deleteData = progress.deleteDataEachSite;
			}
			
			
			// jump into the middle of a game. Similar to calling 'new game', but doesn't necessarily give a clean slate. 
			private function restoreGame(progress:Object):void{											
				mCurrentMission = Missions.getMission(progress.mission);
				popUpScreen.selectedLevel = progress.mission; 	// ensures the correct mission will be highlighted on the map when this game finishes.
				popUpScreen.visible = false;
				sailingMovie.hardReset();
				
				mGameSerialNum = progress.gameSerialNum;
				mSiteSerialNum = progress.siteSerialNum;
				mSitesVisitedThisGame = progress.sitesVisitedThisGame;
				
				Water.fill = mCurrentMission.waterGradient;
				Sky.backgroundFill = mCurrentMission.skyGradient;
				cHerder.cleanClouds();
				cHerder.init( mCurrentMission.cloudPattern);
				cHerder.startClouds();
				
				bootyMeter.nextSiteBtn.visible = mCurrentMission.variableTreasures;
				
				// when restore a variable treasures level, treasures per site needs to be resoted properly.
				if(mCurrentMission.variableTreasures){ 
					numTreasuresPerSite = shuffleTreasuresPerSite();
					for( var j:int = 1; j < progress.sitesVisitedThisGame + 1; j++){
						if(numTreasuresPerSite.length > 0)
							numTreasuresPerSite.shift();
					}
				}
				
				if(mCurrentMission.seaWall){
					posTreasuresPerSite = shufflePositionPerSite();
					for( var k:int = 1; k < progress.sitesVisitedThisGame + 1; k++){
						if(posTreasuresPerSite.length > 0)
							posTreasuresPerSite.shift();
					}
				}
				
				bootyMeter.initialize( mCurrentMission.startingRats, mCurrentMission.missesAllowed);
				bootyMeter.startMidgame( progress.remainingRats, progress.remainingMisses, progress.treasuresFoundThisGame);
				
				mDGInterface.sendLog( "loadGame: GameNumber="+mGameSerialNum+" Mission='"+mCurrentMission.title+"'" );
				
				setRatsToSend( mCurrentMission.ratsInStepper);	// moving this down fixed a bug where the stepper did not properly take the starting # of rats in the stepper. (a very series issue for Mission 1)
				shipControlsMVC.useLargeRatButton = mCurrentMission.fixedRats; 	// if this mission has a fixed # of rats, use the big button instead of the stepper.
				setHookSizes(mCurrentMission.hookSize);
				
				// pile treasures up on the deck:
				crane.resetTreasure();
				for(var i:int = 0; i < progress.treasuresFoundThisGame; i++){
					crane.addTreasure();
					sailingMovie.addTreasure();
				}
				
				// start a new Game case in DG
				sendGameDataOpen();
			}
			
			private function restoreSite( progress:Object):void{
				readyToZoomIn();
				disableAllButtons();
				
				// give some prompt to remind the player where they were. This masks the fact that we can't skip the 'zoom in' animation.
				//popUpScreen.displayMessage("Welcome Back", "You were playing " + mCurrentMission.title + ". So far, you've been to " + progress.sitesVisitedThisGame + " site" + ( + progress.sitesVisitedThisGame > 1 ? "s":"") + " and found " + progress.treasuresFoundThisGame + " treasures.");
				topBarMVC.closeBouncer(null);
				
				mSiteSerialNum			= progress.siteSerialNum; 
				mTreasuresFoundThisSite	= progress.treasuresFoundThisSite;	
				mRatsSentThisSite		= progress.remainingRats - mCurrentMission.startingRats;
				
				var numTreasuresThisSite:int = progress.treasuresRemaining.length; 
				mTreasuresThisSite = new Vector.<Treasure>();
				for( var i:int = 0; i < numTreasuresThisSite; i++)
					mTreasuresThisSite.push( new Treasure( TreasureNamePicker.poolShift( mCurrentMission.number), progress.treasuresRemaining[i]));
				
				// add the already-found treasures:
				if( mTreasuresFoundThisSite > 0){
					for( i = 0; i < progress.hooksDroppedArray.length; i++){
						if( progress.hooksDroppedArray[i][1]){ // this hook drop found a treasure
							var myFoundTreasure:Treasure = new Treasure(  TreasureNamePicker.poolShift( mCurrentMission.number), progress.hooksDroppedArray[i][0]);
							myFoundTreasure.found = true;
							mTreasuresThisSite.push( myFoundTreasure); // add the treasure to the array
						}
					}
				}
				
				
				// Move hook to its starting position.
				mCenterPosition						= 100;	
				shipControlsMVC.hookStepper.value	= mCenterPosition;					// Set stepper to center position.
				mMinHookRange						= mCenterPosition - mCurrentMission.hookRadius;	// Left edge of hook's grasp.
				mMaxHookRange						= mCenterPosition + mCurrentMission.hookRadius; //mHookRadius;	// Right edge of hook's grasp.
				shipControlsMVC.interval.text		= mMinHookRange.toFixed(1) + " â€“ " + mMaxHookRange.toFixed(1);
				hooksDroppedArray = progress.hooksDroppedArray;
				
				mDGInterface.sendLog( "loadSite: Site="+mSiteSerialNum+" SitesVisited="+mSitesVisitedThisGame );
				
				// THIS NEEDS TO BE HANDLED:
				//if( mSitesVisitedThisGame >= 2){ // what is >= 2 for?
				//sendGameDataUpdate(); // send updated SitesVisited to DG
				//}
				
				updateRatLimit();
				updateGameTitle();
				
				if(VersionChecker.isDebug && kDebugMode)
				{
					trace(treasuresFoundString());
				}
			}
			
			
			
		]]>
	</fx:Script>
	
	<s:states>
		<s:State name="TreasureHunt"/>
	</s:states>
	
	<fx:Declarations>	
	</fx:Declarations>

	<!-- Left Sidebar Log -->
	<mx:UIComponent id="bootyMeterContainer" x="20" y="135"/>
	
	<!-- Animated Ship and Crane area -->
	<s:Group id="mGameArea" includeIn="TreasureHunt" x="120" y="121" width="395" height="286">
		<s:BorderContainer id="Sky" width="395" height="186"
						   borderVisible="false" depth="1">
			<s:SWFLoader id="CloudLoader" includeIn="TreasureHunt" complete="initClouds()" depth="2"
						 source="odyssey_assets/cloudHerder.swf"/>
		</s:BorderContainer>	
		<s:Rect id="Water" includeIn="TreasureHunt" x="0" y="186" width="395" height="100" depth="3"
				/>
		<s:SWFLoader id="CraneLoader" includeIn="TreasureHunt" x="0" y="0" width="395" height="286"
					 complete="initCrane()" depth="4" source="odyssey_assets/CraneAnimation.swf"/>
		<s:SWFLoader id="BoatLoader" includeIn="TreasureHunt" x="0" y="0" width="395" height="286"
					 complete="initBoat()" depth="5" source="odyssey_assets/BoatSailAnim.swf"/>
	</s:Group>
	<mx:UIComponent id="uic" x="120" y="121"/> <!--Note: this is used to place the animation masks and must be the same X and Y as 'mGameArea'-->
	<mx:UIComponent id="ratContainer" x="120" y="121" width="395" height="286"/> <!-- container to hold dots for rat animation demo-->
	<mx:UIComponent id="popUpContainer" x="0" y="0"/>

	<!-- Error message for bad version of flash player -->	
	<s:BorderContainer id="BrickWall" visible="false" x="0" y="0"
					   width="{GameScreen.TOTAL_SCREEN_WIDTH}"
					   height="{GameScreen.TOTAL_SCREEN_HEIGHT}" depth="999">
		<s:backgroundFill>
			<s:LinearGradient rotation="90">
				<s:GradientEntry color="0x13B3C2"/>
				<s:GradientEntry color="0x1E5B77"/>
			</s:LinearGradient>
		</s:backgroundFill>
		
		<s:Label id="topLabelError" x="0" y="70" width="{GameScreen.TOTAL_SCREEN_WIDTH}"
				 color="0xffffff" fontFamily="Georgia" fontSize="20" fontWeight="bold"
				 text="You are using an outdated version of Adobe Flash Player." textAlign="center"/>
		<s:Label id="midLabelError" x="0" y="160" width="{GameScreen.TOTAL_SCREEN_WIDTH}"
				 color="0xffffff" fontFamily="Georgia" fontSize="15"
				 text="{'Ship Odyssey requires Flash Player '+ kMinimumRequiredVersion +' or later.'}"
				 textAlign="center"/>
		<s:Label id="midLabel2Error" x="0" y="180" width="{GameScreen.TOTAL_SCREEN_WIDTH}"
				 color="0xffffff" fontFamily="Georgia" fontSize="15"
				 text="{'You are currently using Flash Player ' + VersionChecker.getVersion()}"
				 textAlign="center"/>
		<s:Button id="upgradeButton" x="{(GameScreen.TOTAL_SCREEN_WIDTH-350)/2}" y="250" width="350"
				  height="50" fontFamily="Georgia" label="Upgrade Flash Player" click="VersionChecker.openAdobeWebsite()"
				  enabled="true" fontSize="25"/>
		<s:Button id="ignoreButton" x="{(GameScreen.TOTAL_SCREEN_WIDTH-350)/2}" y="310" width="350"
				  height="30" fontFamily="Georgia" label="Ignore Warning" click="checkSWFLoaders()" enabled="true" fontSize="12"/>
	
	</s:BorderContainer>
	
	<!-- Contains startup video -->
	<s:BorderContainer id="StartupVideo" x="0" y="27" width="518" height="443" visible="false" backgroundColor="0x294867" borderVisible="false">
		<mx:UIComponent	id="videoHolder" x="0" y="20"/>
		<s:Group id="videoControlsContainer" x="160" y="350">
			<s:Button id="playPauseBtn" label="Pause" click="playPauseVideo()" x="0" />
			<s:Button id="replayBtn" label="Replay" click="replayVideo()" x="{playPauseBtn.width}"/>
			<s:Button id="skipBtn" label="Close" chromeColor="#eac42d" color="0x000000" click="hideVideo()" x="{playPauseBtn.width+replayBtn.width+20}" />
		</s:Group>
	</s:BorderContainer>
	
	<mx:UIComponent	id="topBarContainer" x="0" y="0"/>
	
</s:Application>
